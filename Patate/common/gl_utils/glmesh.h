/*
 This Source Code Form is subject to the terms of the Mozilla Public
 License, v. 2.0. If a copy of the MPL was not distributed with this
 file, You can obtain one at http://mozilla.org/MPL/2.0/.
*/

#ifndef _PATATE_COMMON_GL_UTILS_GLMESH_H
#define _PATATE_COMMON_GL_UTILS_GLMESH_H

#ifdef __APPLE__
    #include <OpenGL/gl3.h>
    #include <OpenGL/gl3ext.h>

    #define __gl_h_

#elif defined _MSC_VER
    #include <Windows.h>
    #include <GL/gl.h>

#else
    #define GL_GLEXT_PROTOTYPES

    #include <GL/gl.h>
    #include <GL/glext.h>
#endif

#include "Eigen/Dense"
#include "Patate/common/surface_mesh/surfaceMesh.h"
#include <vector>


namespace PatateCommon
{
/*!
 * \brief The GL3DMesh struct implements basic VBO display for triangular 3d meshes.
 *
 * It can be generated by OBJReader
 */
struct GLTri3DMesh{

public:
    enum { Dim = 3 };
    typedef GLfloat                       Scalar;
    typedef Eigen::Matrix<Scalar, Dim, 1> Vector;
    typedef SurfaceMesh::Vertex           Vertex; // ids


protected:
    inline void computeNormals();

    typedef std::vector<Scalar> VContainer;
    typedef std::vector<GLuint> FContainer;

    VContainer _vertices;
    VContainer _normals;
    FContainer _faces;    //will be the index buffer
    bool _init, _pickingInit;

    GLuint _vao;
    GLuint _vboFaceArray, _vboVertArray, _vboNormalArray, _vboIdsArray;


    //! \brief Iterator binding internal data in GrenaillePoint instances
    template<typename VertexContainer> struct _GrenailleIterator;

    //! \brief Iterator binding internal vertices and normals representation
    template<typename VertexContainer> struct _VectorIterator;

    //! \brief Iterator binding internal data in GrenaillePoint instances, and iterate by faces
    template<typename VertexContainer> struct _FaceIterator;


public:
    typedef _GrenailleIterator<VContainer>             grenailleIterator;
    typedef _GrenailleIterator<const VContainer> const_grenailleIterator;

    typedef _VectorIterator<VContainer>                posIterator;
    typedef _VectorIterator<const VContainer>    const_posIterator;

    typedef _VectorIterator<VContainer>                normalIterator;
    typedef _VectorIterator<const VContainer>    const_normalIterator;

    typedef _FaceIterator<VContainer>                  faceIterator;
    typedef _FaceIterator<const VContainer>      const_faceIterator;

    //! \brief Embedded Point type compatible with Grenaille API
    struct GrenaillePoint
    {
    public:
        enum {Dim = GLTri3DMesh::Dim};
        typedef typename GLTri3DMesh::Scalar Scalar;
        typedef Eigen::Matrix<Scalar, Dim,   1>   VectorType;
        typedef Eigen::Matrix<Scalar, Dim+1, 1>   HVectorType;
        typedef Eigen::Matrix<Scalar, Dim, Dim>   MatrixType;

        inline GrenaillePoint(int id, GLTri3DMesh &mesh)
            : m_pos   (mesh.getVertexMap(id)),
              m_normal(mesh.getNormalVectorMap(id)) {}

        inline GrenaillePoint(Scalar *v, Scalar *n)
            : m_pos   (Eigen::Map< VectorType >(v)),
              m_normal(Eigen::Map< VectorType >(n)) {}

        inline GrenaillePoint()
            : m_pos   (Eigen::Map< VectorType >(NULL)),
              m_normal(Eigen::Map< VectorType >(NULL)) {}

        //! \see http://eigen.tuxfamily.org/dox/group__TutorialMapClass.html
        inline GrenaillePoint& operator=(GrenaillePoint& other){
            new (&m_pos) Eigen::Map< VectorType >(other.m_pos.data(), Dim);
            new (&m_normal) Eigen::Map< VectorType >(other.m_normal.data(), Dim);
            return *this;
        }

        inline const Eigen::Map< VectorType >& pos()    const { return m_pos; }
        inline const Eigen::Map< VectorType >& normal() const { return m_normal; }
        inline Eigen::Map< VectorType >& pos()    { return m_pos; }
        inline Eigen::Map< VectorType >& normal() { return m_normal; }
    private:
        Eigen::Map< VectorType > m_pos, m_normal;
    };

    inline ~GLTri3DMesh() { clearVBO(); }

    inline void addFace(const std::vector<Vertex>& vertices);
    inline void addFace(Vertex v0, Vertex v1, Vertex v2);
    inline void addFace(int v0, int v1, int v2);
    inline void addVertex(const Vector& v);
    inline unsigned int nVertices() const;

    inline grenailleIterator begin();
    inline grenailleIterator end();

    inline posIterator vertexBegin();
    inline posIterator vertexEnd();

    inline normalIterator normalBegin();
    inline normalIterator normalEnd();

    inline faceIterator faceBegin();
    inline faceIterator faceEnd();

    inline GLTri3DMesh();
    inline void initVBO(bool initForPicking = true);
    inline void clearVBO();
    inline void draw();
    // draw ids for picking
    inline void drawIds();
    //! \brief Center geometry to the centroid
    inline void translateToCentroid();

    inline Eigen::Map<Vector> getVertexMap(int id);
    inline Eigen::Map<Vector> getNormalVectorMap(int id);
    inline GrenaillePoint getGrenaillePoint(int id);
};


} // namespace PatateCommon

#include "glmesh.hpp"

#endif // _PATATE_COMMON_GL_UTILS_GLMESH_H

